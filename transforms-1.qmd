---
title: Перетворення змінних
author: Олександр Виноградов
format: html
editor: visual
---

Дослідник завжди після підготовки таблиці даних і їхньої чистки виконує різноманітні перетворення (трансформації) первинних змінних — обчислює композитні показники на основі отриманих відповідей, категоризує неперервні змінні, перекодовує відповіді, чи переводить сирі бали у стандартну шкалу.

## Обчислення композитних змінних

Вони ж "сумарні бали", "сирі бали", "інтегральні показники".

```{r}
M <- readRDS("MRMT-UA.rds")
```

Обчислення нової змінної, коли всі питання-індикатори мають однаковий напрямок ключа:

```{r}
M$swls <- rowSums(M[27:31], na.rm = TRUE) - 5

M $ SWLS <- rowMeans(
  x = M[ 27:31 ], na.rm = TRUE
)
```

Більш загальний випадок, коли є питання-індикатори як з прямим, так і з зворотним ключем. Увага: якщо хоча б одна відповідь респондента відсутня (NA), то й композитний бал буде дорвінювати NA:

```{r}
M <- transform(
  M,
  mrs = (MRS_1 + MRS_2 + MRS_3 + MRS_4 + MRS_5 + 6-MRS_6 + 
    MRS_7 + MRS_8 + 6-MRS_9 + 6-MRS_10) / 10,
  mts = (MTS_1 + MTS_2 + 6-MTS_3 + MTS_4 + 6-MTS_5 +
    MTS_6 + 6-MTS_7 + MTS_8 + MTS_9 + MTS_10) / 10
)

attributes(M$mrs) <- NULL
attributes(M$mts) <- NULL
```

Можна використати зручні функції обчислення сумарних балів з пакету **psych**. Об'єкт з ключами для обчислення композитних змінних у вигляді списку (list). Елементами списку мають бути вектори назв змінних-індикаторів або їхніх номерів. Знак мінус означає зворотний ключ. Назва елементу списку відповідає імені композитної змінної, яку обчислить функція (наприклад, scoreFast()).

Функції **scoreFast()** передають два аргументи: список з ключами і таблицю даних. Додаткові аргументи: totals вказує, обчислювати усереднені значення (за замовчанням) чи сумарні бали, **missing** та **impute** керують тим, як обробляються пропущені відповіді (можуть відкидатися, замінюватися медіаною чи середнім значенням) тощо.

Функція розрахунку композитних балів **scoreFast()** повертає особливий тип об'єкту, з яким ми ще не знайомі — **matrix** (матриця). Матриця є прямокутною таблицею елементів одного і того ссамого типу (найчастіше це числа). Рядки і стовпчики матриці можуть мати довільні текстові підписи, тому матриці краще за все підходять для виведення результатів статистичного аналізу (наприклад, кореляційних матриць).

На матрицях також можна проводити статистичний аналіз, як на списках та таблицях даних. Матриці можна трансформувати у таблицю даних за допомогою функції data.frame(), а потім поєднати з існуючою таблицею за допомогою функції **cbind()** чи **rbind()**.

```{r}
library(psych)

КЛЮЧІ <- list(
  mrs = c(
    "MRS_1", "MRS_2", "MRS_3", "MRS_4", "MRS_5",
    "-MRS_6", "MRS_7","MRS_8",  "-MRS_9", "-MRS_10"
  ),
  mts = c(
    "MTS_1", "MTS_2", "-MTS_3", "MTS_4", "-MTS_5",
    "MTS_6", "-MTS_7", "MTS_8", "MTS_9", "MTS_10"
  ),
  swls = c(
    "SWL_1", "SWL_2", "SWL_3", "SWL_4", "SWL_5"
  )
)

БАЛИ <- scoreFast(
  keys = КЛЮЧІ, items = M, 
)

M <- cbind(
  M, data.frame(БАЛИ)
)
```

Стандартизація змінних – обчислення z-балів. Стандартизація здійснюється за допомогою простого лінійного перетворення: (сирий бал - середнє) / стандартне відхилення

```{r}
M <- transform(
  M,
  Z.MRS <- (MRS - mean(MRS, na.rm = TRUE)) / sd(MRS, na.rm = TRUE)
)

## або використати спеціальну функцію scale():
scale(БАЛИ)
```

## Категоризація неперервних змінних

Функція **cut()** нарізає неперервну змінну на категорії і повертає категоріальну змінну (фактор). За бажанням цей фактор може бути порядковим, тоді аргументу **ordered_result** слід передати значення **TRUE**.

Аргумент breaks визначає кількість категорій або границі між категоріями. Текстові мітки рівнів фактору створюються автоматично, але аргумент labels = FALSE примусить функцію просто нумерувати категорії. Йому можна також передати текстовий вектор з власними назвами категорій.

```{r}
M <- transform(
  M,
  AgeGroup = cut(
    Age, breaks = c(17, 18, 20, 22),
    # labels = c("17-18","19-20","21-22"),
    include.lowest = TRUE
  )
)

table(M$AgeGroup)
```

## Перекодування змінних

Функція **case_match()** з пакету **dplyr** дає можливість замінити одне значення або їх набір на інше значення. Це буває корисно при заміні пропущених відповідей, укрупненні шкали відповідей, зміні порядку категорій:

```{r}
library(dplyr)

M <- transform(
  M,
  R1 = case_match(
    M$MRS_1,
    1:2 ~ -1,
    3 ~ 0,
    4:5 ~ 1,
    NA ~ 0,
    .default = M$MRS_1
  )
)

## Завжди перевіряйте правильність перекодувань!
table(
  M$MRS_1, M$R1, useNA = 'always',
  deparse.level = 2
)
```

Завжди перевіряйте, чи перекодування привело бо результату, який ви планували. Також не забувайте замовляти виведення кодів пропущених значень, щоб розуміти, що з ними відбувається.

## Перетворення за умовою

Необхідність в умовних перетвореннях виникає тоді, коли дослідник вирішує більш складні задачі. Наприклад, при переведенні сирого балу у більш зручну стандартну шкалу, чи врахуванні декількох змінних при класифікації спостережень. Скористаємося для перетворення сирого балу шкали **MRS** у стени функцією **case_when()** з пакету **dplyr**. Для виконання перетворень також використаємо більш зручну і сучасну функцію **mutate()** замість класичної **transform()**.

```{r}
## середнє арифметичне шкали MRS
mean(M$MRS)

## стандартне відхилення шкали MRS
sd(M$MRS)

M <- mutate(
  M,
  Z = (MRS - 2.991939) / 0.5554488,
  S = Z * 2 + 5,
  MRS.S = case_when(
    S < 1 ~ 1,
    S > 9 ~ 9,
    .default = round(S)
  )
)

barplot(
  height = table(M$MRS.S),
  col = rainbow(9),
  main = "Розподіл балів за шкалою MRS",
  xlab = "стени",
  ylab = "частота"
)
```
